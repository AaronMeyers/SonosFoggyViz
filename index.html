<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}

			div {
				position: absolute;
				z-index: 10;
				color: #fff;
				font-family: monospace;
				text-align: center;
				margin: 10px;
				width: 100%;
			}

			label, input {
				cursor: pointer;
			}
		</style>
	</head>
	<body>

		<script src="../three.js/build/three.min.js"></script>
		<script src="./js/fft.js"></script>
		<script src="./js/beatdetektor.js"></script>
		<script src="./js/dat.gui.min.js"></script>


		<script src="../three.js/examples/js/shaders/CopyShader.js"></script>
		<script src="../three.js/examples/js/shaders/DotScreenShader.js"></script>
		<script src="../three.js/examples/js/shaders/RGBShiftShader.js"></script>
		<script src="../three.js/examples/js/shaders/EdgeShader.js"></script>
		<script src="../three.js/examples/js/shaders/EdgeShader2.js"></script>

		<script src="../three.js/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="../three.js/examples/js/postprocessing/RenderPass.js"></script>
		<script src="../three.js/examples/js/postprocessing/MaskPass.js"></script>
		<script src="../three.js/examples/js/postprocessing/ShaderPass.js"></script>

		<div>
			<label for="fft">FFT:</label><input id="fft" type="checkbox" onchange="updateOptions()"/><br />
			<label for="dotScreen">Dot Screen:</label><input id="dotScreen" type="checkbox" onchange="updateOptions()"/><br />
			<label for="rgbShift">RGB Shift:</label><input id="rgbShift" type="checkbox" onchange="updateOptions()" /><br />
			<label for="edge">Edge Detection (Frei-Chen Filter):</label><input id="edge" type="checkbox" onchange="updateOptions()" /><br />
			<label for="edge2">Edge Detection (Sobel Filter):</label><input id="edge2" type="checkbox" onchange="updateOptions()" /><br />

		</div>

		<script>

			var audio = {
				element: null,
				bufferSize: 0,
				signal: null,
				channels: 0,
				rate: 0,
				fft: null,
				bd: null,
				kick_det: null,
				vu: null,
			};

			var audioContext;
			var audioSource;
			var audioData;

			var m_BeatTimer = 0;
			var m_BeatCounter = 0;
			var clearClr = [0, 0, 1];

			var lastKick = new Date().getTime();
			var kickThreshold = 500; // minimum threshold between kicks in ms
			var rects = new Array();
			var displayFFT = false;



			var camera, scene, renderer, composer;

			var dotScreenEffect, rgbShiftEffect, edgeEffect, edgeEffect2;

			init();
			animate();

			function updateOptions() {
				var dotScreen = document.getElementById('dotScreen');
				var rgbShift = document.getElementById('rgbShift');
				var edge = document.getElementById('edge');
				var edge2 = document.getElementById('edge2');

				displayFFT = document.getElementById('fft').checked;


				dotScreenEffect.enabled = dotScreen.checked;
				rgbShiftEffect.enabled = rgbShift.checked;
				edgeEffect.enabled = edge.checked;
				edgeEffect2.enabled = edge2.checked;

			}

			function init() {

				initAudio();

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.OrthographicCamera( 0, window.innerWidth, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
				camera.position.z = 400;

				initRects();

				initPostProcessing();

				window.addEventListener( 'resize', onWindowResize, false );

				updateOptions();

			}

			function initRects() {

				var geometry = new THREE.PlaneGeometry( 1, 1 );
				var material = new THREE.MeshBasicMaterial( {color:0xffffff} );

				var count = 128;
				for ( var i = 0; i < count; i ++ ) {

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.set( ( i / (count-1) ) * window.innerWidth, 0, 0 );
					mesh.scale.x = 5;
					mesh.scale.y = 200;

					scene.add( mesh );
					rects.push( mesh );
				}
			}

			function initPostProcessing() {
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );

				dotScreenEffect = new THREE.ShaderPass( THREE.DotScreenShader );
				dotScreenEffect.uniforms[ 'scale' ].value = 4;
				composer.addPass( dotScreenEffect );

				rgbShiftEffect = new THREE.ShaderPass( THREE.RGBShiftShader );
				rgbShiftEffect.uniforms[ 'amount' ].value = 0.0015;
				composer.addPass( rgbShiftEffect );

				edgeEffect = new THREE.ShaderPass( THREE.EdgeShader );
				edgeEffect.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect.uniforms[ 'aspect' ].value.y = window.innerHeight;
				composer.addPass( edgeEffect );

				edgeEffect2 = new THREE.ShaderPass( THREE.EdgeShader2 );
				edgeEffect2.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect2.uniforms[ 'aspect' ].value.y = window.innerHeight;
				composer.addPass( edgeEffect2 );

				var effect = new THREE.ShaderPass( THREE.CopyShader);
				effect.renderToScreen = true;
				composer.addPass( effect );
			}

			function initAudio() {
				// create the audio context
				if (!audioContext) audioContext = new webkitAudioContext();
				// set some audio variables
				audio.bufferSize = 1024;
				audio.channels = 1;
				audio.rate = audioContext.sampleRate;
				// create a node so we can get callbacks
				audioData = audioContext.createJavaScriptNode(audio.bufferSize, 2, 1);
				// set the callback function
				audioData.onaudioprocess = doWebkitAudio;
				// request permission to get the users mic/input/whatever
				navigator.webkitGetUserMedia( {audio:true}, function( stream ) {
					// create an audio source from the stream
					audioSource = audioContext.createMediaStreamSource( stream );
					// connect it to our node
					audioSource.connect( audioData );
					// route that to the audio context and we're good to go
					audioData.connect( audioContext.destination );
					// set up our FFT analyzer
					audio.fft = new FFT(audio.bufferSize, audio.rate);
				});
				// initialize beat detector and modules
				audio.bd = new BeatDetektor();
				audio.kick_det = new BeatDetektor.modules.vis.BassKick();
				audio.vu = new BeatDetektor.modules.vis.VU();
			}

			function doWebkitAudio() {
				if ( !audio.fft ) {
					return;
				}

				var signalLeft = event.inputBuffer.getChannelData(0);
				var signalRight = event.inputBuffer.getChannelData(1);

				if (!audio.signal) {
					audio.signal = new Float32Array(signalLeft.length);
				}
				for (var i = 0, fbl = audio.bufferSize; i < fbl; i++) {
					audio.signal[i] = signalLeft[i] + signalRight[i] / 2;
				}

				audio.fft.forward(audio.signal);
				audio.bd.process(event.timeStamp / 1000, audio.fft.spectrum);

				if (audio.bd.win_bpm_int_lo) {
					m_BeatTimer += audio.bd.last_update;

					if (m_BeatTimer > (60.0 / audio.bd.win_bpm_int_lo)) {
						m_BeatTimer -= (60.0 / audio.bd.win_bpm_int_lo);
						clearClr[0] = 0.5 + Math.random() / 2;
						clearClr[1] = 0.5 + Math.random() / 2;
						clearClr[2] = 0.5 + Math.random() / 2;
						m_BeatCounter++;
					}
				}

				audio.kick_det.process( audio.bd );

				if ( audio.kick_det.isKick() ) {
					var diff = event.timeStamp - lastKick;
					if ( diff > kickThreshold ) {
						// A KICK HAPPENED HERE
						lastKick = event.timeStamp;
					}

				}

				for ( var i=0; i<audio.vu.vu_levels.length; i++ ) {
					var rect = rects[i];
					var vu = audio.vu.vu_levels[i];
					if ( displayFFT )
						vu = audio.fft.spectrum[i*4] * 10.0;
					vu = Math.max( .01, vu );
					rect.scale.y = 250.0 * vu;
				}

                audio.vu.process(audio.bd, event.timeStamp / 1000);
			}

			function onWindowResize() {
				camera.left = 0;
				camera.right = window.innerWidth;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / - 2;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				edgeEffect.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect.uniforms[ 'aspect' ].value.y = window.innerHeight;
				edgeEffect2.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect2.uniforms[ 'aspect' ].value.y = window.innerHeight;

			}

			function animate() {

				requestAnimationFrame( animate );

				var time = Date.now();

				composer.render();
				// renderer.render(scene, camera);

			}

		</script>
	</body>
</html>
