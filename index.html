<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}

			div {
				position: absolute;
				z-index: 10;
				color: #fff;
				font-family: monospace;
				text-align: center;
				margin: 10px;
				width: 100%;
			}

			label, input {
				cursor: pointer;
			}
		</style>
	</head>
	<body>

		<script src="../three.js/build/three.min.js"></script>
		<script src="./js/fft.js"></script>
		<script src="./js/beatdetektor.js"></script>


		<script src="../three.js/examples/js/shaders/CopyShader.js"></script>
		<script src="../three.js/examples/js/shaders/DotScreenShader.js"></script>
		<script src="../three.js/examples/js/shaders/RGBShiftShader.js"></script>
		<script src="../three.js/examples/js/shaders/EdgeShader.js"></script>
		<script src="../three.js/examples/js/shaders/EdgeShader2.js"></script>

		<script src="../three.js/examples/js/postprocessing/EffectComposer.js"></script>
		<script src="../three.js/examples/js/postprocessing/RenderPass.js"></script>
		<script src="../three.js/examples/js/postprocessing/MaskPass.js"></script>
		<script src="../three.js/examples/js/postprocessing/ShaderPass.js"></script>

		<div>
			<label for="fft">FFT:</label><input id="fft" type="checkbox" onchange="updateOptions()"/><br />
			<label for="dotScreen">Dot Screen:</label><input id="dotScreen" type="checkbox" onchange="updateOptions()"/><br />
			<label for="rgbShift">RGB Shift:</label><input id="rgbShift" type="checkbox" onchange="updateOptions()" /><br />
			<label for="edge">Edge Detection (Frei-Chen Filter):</label><input id="edge" type="checkbox" onchange="updateOptions()" /><br />
			<label for="edge2">Edge Detection (Sobel Filter):</label><input id="edge2" type="checkbox" onchange="updateOptions()" /><br />

		</div>

		<script>

			var audio = {
				element: null,
				bufferSize: 0,
				signal: null,
				channels: 0,
				rate: 0,
				fft: null,
				bd: null,
				kick_det: null,
				vu: null,
			};

			var lastKick = new Date().getTime();
			var rects = new Array();
			var displayFFT = false;


			var m_BeatTimer = 0;
			var m_BeatCounter = 0;
			var clearClr = [0, 0, 1];

			var camera, scene, renderer, composer;
			var object, light;

			var audioContext = new webkitAudioContext();
			var audioAnalyser;// = audioContext.createAnalyser();
			var audioSource;
			var audioData;
			var audioActive = false;

			var dotScreenEffect, rgbShiftEffect, edgeEffect, edgeEffect2;

			init();
			animate();


			function initAudio() {


				audio.bufferSize = 1024;
				audio.channels = 1;

				if (!audioContext) audioContext = new webkitAudioContext();

				audio.rate = audioContext.sampleRate;
				audioData = audioContext.createJavaScriptNode(audio.bufferSize, 2, 1);

				audioData.onaudioprocess = doWebkitAudio;

				navigator.webkitGetUserMedia( {audio:true}, function( stream ) {

					audioSource = audioContext.createMediaStreamSource( stream );
					// this is what starts the callback
					audioSource.connect( audioData );
					audioData.connect( audioContext.destination );

					audio.fft = new FFT(audio.bufferSize, audio.rate);

				});

				audio.bd = new BeatDetektor();
				audio.kick_det = new BeatDetektor.modules.vis.BassKick();
				audio.vu = new BeatDetektor.modules.vis.VU();


			}

			function initFFT() {
				console.log( 'initFFT' );
				navigator.webkitGetUserMedia( {audio:true}, function(stream) {
					console.log( 'audio permission granted' );
					audioSource = audioContext.createMediaStreamSource( stream );
					audioAnalyser = audioContext.createAnalyser();
					audioSource.connect( audioAnalyser );

					audioData = audioContext.createJavaScriptNode( 1024, 2, 1 );
					audioData.onaudioprocess = doWebkitAudio;
					audioData.connect(audioContext.destination);

					audioActive = true;
				});

			}

			function doWebkitAudio() {
				if ( !audio.fft ) {
					return;
				}

				var signalLeft = event.inputBuffer.getChannelData(0);
				var signalRight = event.inputBuffer.getChannelData(1);

				if (!audio.signal) {
					audio.signal = new Float32Array(signalLeft.length);
				}
				for (var i = 0, fbl = audio.bufferSize; i < fbl; i++) {
					audio.signal[i] = signalLeft[i] + signalRight[i] / 2;
				}
				// console.log( 'audio signal at 100: ' + audio.signal[100] );

				audio.fft.forward(audio.signal);
				audio.bd.process(event.timeStamp / 1000, audio.fft.spectrum);

				if (audio.bd.win_bpm_int_lo) {
					m_BeatTimer += audio.bd.last_update;

					if (m_BeatTimer > (60.0 / audio.bd.win_bpm_int_lo)) {
						m_BeatTimer -= (60.0 / audio.bd.win_bpm_int_lo);
						clearClr[0] = 0.5 + Math.random() / 2;
						clearClr[1] = 0.5 + Math.random() / 2;
						clearClr[2] = 0.5 + Math.random() / 2;
						m_BeatCounter++;
					}
				}

				audio.kick_det.process( audio.bd );

				var timestamp = new Date().getTime();
				if ( audio.kick_det.isKick() ) {
					// console.log( 'lastKick: ' + lastKick );
					var diff = timestamp - lastKick;
					// console.log( 'diff: ' + diff );
					if ( diff > 500 ) {
						lastKick = timestamp;
						console.log( "kick at " + lastKick );
					}

				}

				for ( var i=0; i<audio.vu.vu_levels.length; i++ ) {
					var rect = rects[i];
					var vu = audio.vu.vu_levels[i];
					if ( displayFFT )
						vu = audio.fft.spectrum[i*4] * 10.0;
					vu = Math.max( .01, vu );
					rect.scale.y = 250.0 * vu;
				}

                audio.vu.process(audio.bd, event.timeStamp / 1000);
			}

			function doFFT() {

				return;

				if ( !audioActive )
					return;

				var array = new Uint8Array( audioAnalyser.frequencyBinCount );
				audioAnalyser.getByteFrequencyData(array);
				var audible_bands = array.subarray(0, 1024);

				// console.log( "value for 100: " + audible_bands[100] );


			}

			function updateOptions() {
				var dotScreen = document.getElementById('dotScreen');
				var rgbShift = document.getElementById('rgbShift');
				var edge = document.getElementById('edge');
				var edge2 = document.getElementById('edge2');

				displayFFT = document.getElementById('fft').checked;


				dotScreenEffect.enabled = dotScreen.checked;
				rgbShiftEffect.enabled = rgbShift.checked;
				edgeEffect.enabled = edge.checked;
				edgeEffect2.enabled = edge2.checked;

			}

			function init() {

				initAudio();
				// initFFT();

				// fft
				// .start()
				// .bind('update', function(bands) {
				// 	console.log( 'callback', bands.length );
				// });

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				// camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				// camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
				camera = new THREE.OrthographicCamera( 0, window.innerWidth, window.innerHeight / 2, window.innerHeight / - 2, - 500, 1000 );
				camera.position.z = 400;

				var geometry = new THREE.PlaneGeometry( 1, 1 );
				var material = new THREE.MeshBasicMaterial( {color:0xffffff} );

				var count = 128;
				for ( var i = 0; i < count; i ++ ) {

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.set( ( i / (count-1) ) * window.innerWidth, 0, 0 );
					mesh.scale.x = 5;
					mesh.scale.y = 200;

					scene.add( mesh );
					rects.push( mesh );
				}

				// postprocessing

				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );

				dotScreenEffect = new THREE.ShaderPass( THREE.DotScreenShader );
				dotScreenEffect.uniforms[ 'scale' ].value = 4;
				composer.addPass( dotScreenEffect );

				rgbShiftEffect = new THREE.ShaderPass( THREE.RGBShiftShader );
				rgbShiftEffect.uniforms[ 'amount' ].value = 0.0015;
				composer.addPass( rgbShiftEffect );

				edgeEffect = new THREE.ShaderPass( THREE.EdgeShader );
				edgeEffect.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect.uniforms[ 'aspect' ].value.y = window.innerHeight;
				composer.addPass( edgeEffect );

				edgeEffect2 = new THREE.ShaderPass( THREE.EdgeShader2 );
				edgeEffect2.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect2.uniforms[ 'aspect' ].value.y = window.innerHeight;
				composer.addPass( edgeEffect2 );

				var effect = new THREE.ShaderPass( THREE.CopyShader);
				effect.renderToScreen = true;
				composer.addPass( effect );

				window.addEventListener( 'resize', onWindowResize, false );

				updateOptions();

			}

			function onWindowResize() {

				// camera.aspect = window.innerWidth / window.innerHeight;
				// camera.updateProjectionMatrix();

				// camera.left = window.innerWidth / - 2;
				camera.left = 0;
				camera.right = window.innerWidth;
				camera.top = window.innerHeight / 2;
				camera.bottom = window.innerHeight / - 2;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				edgeEffect.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect.uniforms[ 'aspect' ].value.y = window.innerHeight;
				edgeEffect2.uniforms[ 'aspect' ].value.x = window.innerWidth;
				edgeEffect2.uniforms[ 'aspect' ].value.y = window.innerHeight;

			}

			function animate() {

				doFFT();

				requestAnimationFrame( animate );

				var time = Date.now();

				composer.render();
				// renderer.render(scene, camera);

			}

		</script>
	</body>
</html>
